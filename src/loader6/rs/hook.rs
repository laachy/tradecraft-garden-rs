#![no_std]
#![no_main]

#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! { loop {} }

use crystal_palace_rs::import;
use crystal_palace_sys::tcg::{__resolve_hook, IMPORTFUNCS, ror13hash};
use winapi::shared::{minwindef::{FARPROC, HMODULE}, ntdef::LPCSTR};

import!(LoadLibraryA(arg1: LPCSTR) -> HMODULE);
import!(GetProcAddress(arg1: HMODULE, arg2: LPCSTR) -> FARPROC);

/*
 * This is the GetProcAddress our loader will use. It's a chance for us to hook things.  The
 * __resolve_hook() function is an intrinsic function replaced with code generated by our
 * linker. It will turn a function ror13 hash into a local hook function pointer. Use addhook
 * in the .spec file to register hooks
 */
#[unsafe(no_mangle)]
extern "system" fn _GetProcAddress(h_module: HMODULE, lp_proc_name: LPCSTR) -> FARPROC {
    unsafe {
        let result = __resolve_hook(ror13hash(lp_proc_name));
        if !result.is_null() {
            return result;
        }
        GetProcAddress(h_module, lp_proc_name)
    }
}

#[unsafe(no_mangle)]
extern "C" fn go(funcs: *mut IMPORTFUNCS) {
    /* update the GetProcAddress our loader uses */
    unsafe { (*funcs).GetProcAddress = Some(_GetProcAddress) };
}